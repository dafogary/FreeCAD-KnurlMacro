# -*- coding: utf-8 -*-
"""
FreeCAD Knurl Macro
===================

A comprehensive macro for creating various knurl patterns on cylindrical surfaces in FreeCAD.

Copyright (C) 2025 Gary Foster - DAFO Creative Ltd/LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
import math
from PySide import QtGui, QtCore

doc = App.ActiveDocument
sel = Gui.Selection.getSelectionEx()

if not sel:
    raise Exception("Please select a cylindrical edge, face, or solid")

obj = sel[0].Object
shape = obj.Shape

# ---------------- KNURL PARAMETER DIALOG ----------------
class KnurlDialog(QtGui.QDialog):
    def __init__(self):
        super(KnurlDialog, self).__init__()
        self.initUI()
        
    def initUI(self):
        self.setWindowTitle('Knurl Parameters')
        self.setMinimumWidth(400)
        
        layout = QtGui.QVBoxLayout()
        
        # Knurl Pattern Type
        pattern_group = QtGui.QGroupBox("Knurl Pattern")
        pattern_layout = QtGui.QVBoxLayout()
        
        self.pattern_combo = QtGui.QComboBox()
        self.pattern_combo.addItems([
            "Diamond Knurl (Cross Pattern)",
            "Straight Knurl (Parallel Lines)",
            "Diagonal Knurl (Single Direction)",
            "Left-Hand Diagonal",
            "Right-Hand Diagonal"
        ])
        self.pattern_combo.currentIndexChanged.connect(self.pattern_changed)
        pattern_layout.addWidget(QtGui.QLabel("Pattern Type:"))
        pattern_layout.addWidget(self.pattern_combo)
        pattern_group.setLayout(pattern_layout)
        layout.addWidget(pattern_group)
        
        # Tooth Profile
        profile_group = QtGui.QGroupBox("Tooth Profile")
        profile_layout = QtGui.QVBoxLayout()
        
        self.profile_combo = QtGui.QComboBox()
        self.profile_combo.addItems([
            "Sharp (V-Profile) - Aggressive grip",
            "Rounded - Comfortable touch",
            "Flat-Top - Durable, less aggressive"
        ])
        profile_layout.addWidget(QtGui.QLabel("Profile Type:"))
        profile_layout.addWidget(self.profile_combo)
        profile_group.setLayout(profile_layout)
        layout.addWidget(profile_group)
        
        # Pitch (Coarseness)
        pitch_group = QtGui.QGroupBox("Pitch (Tooth Spacing)")
        pitch_layout = QtGui.QVBoxLayout()
        
        self.pitch_combo = QtGui.QComboBox()
        self.pitch_combo.addItems([
            "Fine (1.0mm) - Precision parts",
            "Medium (2.0mm) - General purpose",
            "Coarse (3.0mm) - Heavy duty",
            "Extra Coarse (4.0mm) - Industrial",
            "Custom"
        ])
        self.pitch_combo.currentIndexChanged.connect(self.pitch_changed)
        pitch_layout.addWidget(QtGui.QLabel("Pitch Preset:"))
        pitch_layout.addWidget(self.pitch_combo)
        
        # Custom pitch input
        pitch_custom_layout = QtGui.QHBoxLayout()
        pitch_custom_layout.addWidget(QtGui.QLabel("Custom Pitch (mm):"))
        self.pitch_spin = QtGui.QDoubleSpinBox()
        self.pitch_spin.setRange(0.5, 10.0)
        self.pitch_spin.setValue(2.0)
        self.pitch_spin.setSingleStep(0.1)
        self.pitch_spin.setEnabled(False)
        pitch_custom_layout.addWidget(self.pitch_spin)
        pitch_layout.addLayout(pitch_custom_layout)
        
        pitch_group.setLayout(pitch_layout)
        layout.addWidget(pitch_group)
        
        # Depth
        depth_group = QtGui.QGroupBox("Knurl Depth")
        depth_layout = QtGui.QVBoxLayout()
        
        depth_input_layout = QtGui.QHBoxLayout()
        depth_input_layout.addWidget(QtGui.QLabel("Depth (mm):"))
        self.depth_spin = QtGui.QDoubleSpinBox()
        self.depth_spin.setRange(0.1, 5.0)
        self.depth_spin.setValue(0.6)
        self.depth_spin.setSingleStep(0.1)
        depth_input_layout.addWidget(self.depth_spin)
        depth_layout.addLayout(depth_input_layout)
        
        depth_group.setLayout(depth_layout)
        layout.addWidget(depth_group)
        
        # Angle (for diagonal patterns)
        angle_group = QtGui.QGroupBox("Angle")
        angle_layout = QtGui.QVBoxLayout()
        
        angle_input_layout = QtGui.QHBoxLayout()
        angle_input_layout.addWidget(QtGui.QLabel("Knurl Angle (degrees):"))
        self.angle_spin = QtGui.QSpinBox()
        self.angle_spin.setRange(15, 75)
        self.angle_spin.setValue(35)
        self.angle_spin.setSingleStep(5)
        angle_input_layout.addWidget(self.angle_spin)
        angle_layout.addLayout(angle_input_layout)
        
        angle_layout.addWidget(QtGui.QLabel("(30-45° typical for diamond, 90° for straight)"))
        
        angle_group.setLayout(angle_layout)
        self.angle_group = angle_group
        layout.addWidget(angle_group)
        
        # Band width (for edge selection)
        band_group = QtGui.QGroupBox("Knurl Band Width / Height")
        band_layout = QtGui.QVBoxLayout()
        
        band_width_layout = QtGui.QHBoxLayout()
        band_width_layout.addWidget(QtGui.QLabel("Band Width (mm):"))
        self.band_spin = QtGui.QDoubleSpinBox()
        self.band_spin.setRange(1.0, 100.0)
        self.band_spin.setValue(10.0)
        self.band_spin.setSingleStep(1.0)
        band_width_layout.addWidget(self.band_spin)
        band_layout.addLayout(band_width_layout)
        
        band_layout.addWidget(QtGui.QLabel("(For edge selection: sets knurl band height)\n(For face selection: ignored, knurls entire face)"))
        
        band_group.setLayout(band_layout)
        layout.addWidget(band_group)
        
        # Buttons
        button_layout = QtGui.QHBoxLayout()
        self.ok_button = QtGui.QPushButton("Apply Knurl")
        self.cancel_button = QtGui.QPushButton("Cancel")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        
    def pattern_changed(self, index):
        # Enable/disable angle for straight knurl
        if index == 1:  # Straight knurl
            self.angle_spin.setValue(90)
            self.angle_group.setEnabled(False)
        else:
            self.angle_group.setEnabled(True)
            if index == 0:  # Diamond
                self.angle_spin.setValue(35)
            elif index == 3:  # Left-hand
                self.angle_spin.setValue(-35)
            elif index == 4:  # Right-hand
                self.angle_spin.setValue(35)
                
    def pitch_changed(self, index):
        if index == 4:  # Custom
            self.pitch_spin.setEnabled(True)
        else:
            self.pitch_spin.setEnabled(False)
            pitches = [1.0, 2.0, 3.0, 4.0, 2.0]
            if index < len(pitches):
                self.pitch_spin.setValue(pitches[index])
    
    def get_parameters(self):
        pattern_index = self.pattern_combo.currentIndex()
        profile_index = self.profile_combo.currentIndex()
        
        # Determine pattern type
        if pattern_index == 0:  # Diamond
            pattern_type = "diamond"
        elif pattern_index == 1:  # Straight
            pattern_type = "straight"
        else:  # Diagonal variants
            pattern_type = "diagonal"
        
        return {
            'pattern_type': pattern_type,
            'profile': profile_index,
            'pitch': self.pitch_spin.value(),
            'depth': self.depth_spin.value(),
            'angle': self.angle_spin.value(),
            'band_width': self.band_spin.value()
        }

# Show dialog and get parameters
dialog = KnurlDialog()
if dialog.exec_() != QtGui.QDialog.Accepted:
    raise Exception("Operation cancelled by user")

params = dialog.get_parameters()

# ---------------- USER OPTIONS (from dialog) ----------------
knurl_depth = params['depth']
knurl_pitch = params['pitch']
knurl_angle = abs(params['angle'])
pattern_type = params['pattern_type']
profile_type = params['profile']
knurl_band_width = params['band_width']
max_cuts = 200  # Safety limit
# ----------------------------------------------

# Try to find what was selected
selected_edges = sel[0].SubObjects if sel[0].SubObjects else []

# Check if an edge was selected
cyl_edge = None
cyl_face = None

if selected_edges:
    # Something specific was selected (edge or face)
    for sub in selected_edges:
        if hasattr(sub, 'Curve') and isinstance(sub.Curve, Part.Circle):
            # Selected edge is circular - this defines our knurl area
            cyl_edge = sub
            break
        elif hasattr(sub, 'Surface') and isinstance(sub.Surface, Part.Cylinder):
            # Selected face is cylindrical
            cyl_face = sub
            break

# If no specific selection, try to find a cylindrical face in the whole shape
if cyl_edge is None and cyl_face is None:
    for f in shape.Faces:
        if isinstance(f.Surface, Part.Cylinder):
            cyl_face = f
            break

if cyl_edge is None and cyl_face is None:
    raise Exception("No cylindrical edge or face found. Select a circular edge or cylindrical face.")

# Extract cylinder properties
if cyl_edge:
    # Working with a selected circular edge
    print("Working with selected circular edge")
    radius = cyl_edge.Curve.Radius
    center = cyl_edge.Curve.Center
    axis = cyl_edge.Curve.Axis.normalize()
    
    # Use band width from dialog
    height = knurl_band_width
    
    print(f"Edge detected - will create {knurl_band_width:.2f}mm wide knurl band")
else:
    # Working with a cylindrical face
    print("Working with cylindrical face")
    radius = cyl_face.Surface.Radius
    axis = cyl_face.Surface.Axis.normalize()
    
    # Get the bounding box to find the actual face extent
    bbox = cyl_face.BoundBox
    
    # Calculate the center of the face (not the Surface.Center which may be elsewhere)
    # Use the center of the bounding box
    face_center = App.Vector(
        (bbox.XMin + bbox.XMax) / 2,
        (bbox.YMin + bbox.YMax) / 2,
        (bbox.ZMin + bbox.ZMax) / 2
    )
    center = face_center
    
    # Find the height along the cylinder axis direction
    if abs(axis.z) > 0.9:  # Cylinder axis is mostly aligned with Z
        height = bbox.ZLength
    elif abs(axis.y) > 0.9:  # Cylinder axis is mostly aligned with Y
        height = bbox.YLength
    elif abs(axis.x) > 0.9:  # Cylinder axis is mostly aligned with X
        height = bbox.XLength
    else:
        # For arbitrary orientation, use the maximum dimension
        height = max(bbox.XLength, bbox.YLength, bbox.ZLength)
    
    print(f"Face detected - will knurl entire face height of {height:.2f}mm")
    print(f"Face center at: {center}")

# Calculate number of cuts with safety limit
circumference = 2 * math.pi * radius
count = min(max_cuts // 2, max(6, int(circumference / knurl_pitch)))

print(f"Knurl Pattern: {pattern_type.upper()}")
print(f"Cylinder properties: radius={radius:.2f}mm, height={height:.2f}mm")
print(f"Cylinder axis: {axis}, center: {center}")
print(f"Parameters: pitch={knurl_pitch}mm, depth={knurl_depth}mm, angle={knurl_angle}°")
print(f"Circumference={circumference:.2f}mm")

# Adjust cut count based on pattern
if pattern_type == "straight":
    total_cuts = count
    print(f"Creating {count} straight cuts")
elif pattern_type == "diagonal":
    total_cuts = count
    print(f"Creating {count} diagonal cuts")
else:  # diamond
    total_cuts = count * 2
    print(f"Creating {count * 2} cuts (diamond pattern)")

def make_cut(angle_sign, rot_angle):
    # The length should match the knurl band height, not extend beyond it
    length = height  # Exact height of knurl band
    
    # Adjust dimensions based on profile type
    if profile_type == 0:  # Sharp (V)
        width = knurl_depth * 0.8
        depth = knurl_depth * 3
    elif profile_type == 1:  # Rounded
        width = knurl_depth * 1.2
        depth = knurl_depth * 2.5
    else:  # Flat-top
        width = knurl_depth * 1.5
        depth = knurl_depth * 2.0
    
    # Create cutting box
    box = Part.makeBox(depth, width, length)
    
    # Position box: depth goes radially inward, width is circumferential, length is axial
    box.translate(App.Vector(radius - depth, -width/2, -length/2))
    
    # For diamond/diagonal knurl, rotate the box around the X-axis
    # This tilts it relative to the cylinder axis, creating the helical groove
    if pattern_type != "straight":
        # Calculate the rotation point at the cylinder surface
        pivot = App.Vector(radius, 0, 0)
        # Rotate around X-axis (which points radially outward)
        box.rotate(pivot, App.Vector(1, 0, 0), angle_sign * knurl_angle)
    
    # Rotate around the Z-axis (cylinder axis) to position around the circumference
    box.rotate(App.Vector(0, 0, 0), App.Vector(0, 0, 1), rot_angle)
    
    # Transform to align with the actual cylinder axis if needed
    z_axis = App.Vector(0, 0, 1)
    
    if not axis.isEqual(z_axis, 1e-6) and not axis.isEqual(z_axis * -1, 1e-6):
        # Need to rotate to align with cylinder axis
        rotation_axis = z_axis.cross(axis)
        rotation_angle = math.degrees(math.acos(z_axis.dot(axis)))
        box.rotate(App.Vector(0, 0, 0), rotation_axis, rotation_angle)
    elif axis.isEqual(z_axis * -1, 1e-6):
        # Cylinder axis points in -Z direction
        box.rotate(App.Vector(0, 0, 0), App.Vector(1, 0, 0), 180)
    
    # Finally move to cylinder center
    box.translate(center)
    
    return box

# Create cuts based on pattern type
cuts = []
for i in range(count):
    rot_angle = i * (360.0 / count)
    try:
        if pattern_type == "diamond":
            # Diamond pattern: both left and right cuts
            cuts.append(make_cut(1, rot_angle))
            cuts.append(make_cut(-1, rot_angle))
        elif pattern_type == "straight":
            # Straight pattern: no angle
            cuts.append(make_cut(0, rot_angle))
        else:  # diagonal
            # Single direction diagonal
            direction = 1 if params['angle'] >= 0 else -1
            cuts.append(make_cut(direction, rot_angle))
    except Exception as e: 
        print(f"Warning: Failed to create cut {i}: {e}")

if not cuts:
    raise Exception("Failed to create any cuts")

print(f"Created {len(cuts)} cutting tools")

# Show first few cuts to verify pattern
if len(cuts) >= 2:
    print(f"Cuts spaced every {360.0/count:.2f}° around circumference")
    if pattern_type == "diamond":
        print(f"Diamond pattern: pairs of cuts at +{knurl_angle}° and -{knurl_angle}°")
    elif pattern_type == "straight":
        print(f"Straight pattern: parallel cuts at 90°")
    else:
        print(f"Diagonal pattern: single direction at {knurl_angle}°")

print("")
print("TIP: To visualize cutting tools before applying, edit the macro and set ENABLE_DEBUG = True around line 356")
print("")

# DEBUG: Uncomment these lines to visualize the cutting tools
ENABLE_DEBUG = False  # Set to True to see cutting tools before applying
if ENABLE_DEBUG:
    for idx, cut in enumerate(cuts[:8]):  # Show first 8 cuts
        debug_obj = doc.addObject("Part::Feature", f"DebugCut{idx}")
        debug_obj.Shape = cut
        # Alternate colors for left/right cuts in diamond pattern
        if pattern_type == "diamond":
            debug_obj.ViewObject.ShapeColor = (1.0, 0.0, 0.0) if idx % 2 == 0 else (0.0, 0.0, 1.0)
        else:
            debug_obj.ViewObject.ShapeColor = (1.0, 0.0, 0.0)
    print(f"DEBUG: Created visualization of first {min(8, len(cuts))} cutting tools")
    if pattern_type == "diamond":
        print("DEBUG: Red = right-hand cuts (+angle), Blue = left-hand cuts (-angle)")
    doc.recompute()
    Gui.SendMsgToActiveView("ViewFit")
    raise Exception("Debug mode enabled - stopping before applying cuts. Set ENABLE_DEBUG = False to apply knurl.")

print("Performing boolean cut operations...")

# Perform cuts in batches to avoid overwhelming FreeCAD
batch_size = 20
result = shape

for i in range(0, len(cuts), batch_size):
    batch = cuts[i:i+batch_size]
    tool = Part.makeCompound(batch)
    try:
        result = result.cut(tool)
        print(f"Batch {i//batch_size + 1}/{(len(cuts)-1)//batch_size + 1} complete")
    except Exception as e: 
        print(f"ERROR in batch {i}: {e}")
        import traceback
        traceback.print_exc()

# Clean up the result
try:
    result = result.removeSplitter()
    print("Applied removeSplitter")
except:
    print("Warning: removeSplitter failed, using raw result")

# Check if the shape actually changed
if result.isEqual(shape):
    print("WARNING: Result shape is identical to input - no cuts were applied!")
    print("This might mean the cutting tools don't intersect with the geometry.")
else:
    print(f"Shape modified: Original volume = {shape.Volume:.2f}, New volume = {result.Volume:.2f}")

# Create new object with knurled shape
knurled = doc.addObject("Part::Feature", "Knurled")
knurled.Shape = result
knurled.ViewObject.ShapeColor = (0.8, 0.8, 0.8)  # Light gray color

# Optionally hide the original object instead of deleting it
obj.ViewObject.Visibility = False

doc.recompute()
Gui.SendMsgToActiveView("ViewFit")
print("Knurling complete! Check the 'Knurled' object.")
print(f"If no knurl is visible, try adjusting knurl_depth (currently {knurl_depth}mm) or knurl_pitch (currently {knurl_pitch}mm)")
